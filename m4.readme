# EE 预定义的Macros要被声明
# 
# EE macro protoype
# macroName (string, [count = ‘1’], [argument ]. . . )
# 
# EE 在M4中所有的宏参数都是strings
 
# EE 命名 和C 一样

# EE define
# 内建Macro 创建一个新的Macro
# 参数前的空格都会被忽略
# e.g
define(NAME,evan. Zhao)
hello NAME

# EE 重定义
# define(NAME,fuck)
# 在重定义是NAME会扩展为evan. Zhao
# 其实是define(evan. Zhao,func)
# 使用`'quoting 就可以解决问题
# define(`NAME', fuck)
# 如果name不是宏`name'和name的效果一样

# define(`XX', `OO') 给参数加quing也是阻止宏替换不过一个Quit没用
# 要两个。 为啥？？
 
# EE undefine(`macroName')
# 必须使用`' quoting macro name

# EE dnl Macro 'delete to '
# define时会有一个newline符，输出时也会把这个newline
# 输出，使用dnl就不会输出这个newline.(原先define的位置不会有
# 一个空行）
# ! dnl与define之间不能有括号
define(NA, william)dnl
hello NA

# EE `' Quoting and apostrophe
# 被`'包围的宏名将不被扩展
# 注意是反引号和引号
#1 Quoting `NA'
#2 用`'包围的string可以包含换行符
#e.g
#  `ok.
#  ye.'
#3 `'可以转义自己
#``HH'' -> `HH'
#4 单个括号可以使用`'保护
#e.g
#define(LP,`(')
#define(RP,`)'
LP...RP -> (...)

#EE Common 注释
#默认为# 注释会回显到输出
#注释也可被`'转义为一般字符

#不想回显可以使用dnl 
#e.g dnl # not echoed
#
#块注释不想回显可以这样写
#ifelse(`this common
#will not echoed')dnl
#
# EE changecom
# 改变默认注释界定符。
# 没有参数的changecom调用将会回复默认设置
# e.g changecom('@@')
# 如果想使用块注释，是以使用closing delimiter
# e.g changecom('/*,*/')
# /*fesf 
# fff*/


# m4 的工作原理
# 读入input，替换宏，如果有在从头扫描上次替换后的input
# 如有宏再次替换，直到没有为止。递归的(resucesd)


# EE 计算
# 提供eval函数 操作符和C一致
# incr decr 内置
#define(`INC', `incr(`$1')')
#INC(1)

# EE string
# len e.g len(`fesf')
# substr: (`string', begin, [end])
# e.g substr(`fesf', 1, 3) index begin in 0
# index

# EE 定义一个新宏
# 宏可以被定义，重定义，删除用多种方式。
# 使用define定义。 define(naem, [expansion])
# 如果没有expansion 就是一个空串
# 如果都差define一个macro，他最上面的那个define
# 会被改变


#
## EE --prefix-builtins or -P
#重命名所有的内建Macros以m4_开头
#

# EE 调用macro时和c的函数一样，从后往前解析参数？？？
# 调用Macro 和C 中的很像，有参数时，名字必须和（没有间隔
# 没有参数是不能使用name() 这个是有一个empty string的调用
# 所有参数都是string
# macro(arg1, arg2, ..., argn)
# 缺少的参数会用empty string。
# 多的参数会忽略

#EE 阻止调用macro
#1.使用quting 扩住一个macro name
#

# EE 参数
# 任何不Qutiong的argument 前面的空白都会忽略
#Macro名字不一定一个个单词，可以是任何字符串
#不是正规的名字不会被识别，但可以用indir和defn引用
#macro的参数以$n代替 like shell n begine 1
#macro 的特殊参数和bash 几乎一样
#$0 总是Macro的名字,
#在扫描之前会替换参数,要Quting 否则会导致无限递归。。。？？？
# '$#' 是实际传递的参数个数
# `$*' 所有的参数.替换成arg1,arg2,...,argn
# `$@' 和$*相同，但是他会把每个参数qutiong 

# renaming macros
# use defn(name...)
#

#临时重定义宏
#使用pushdef,popdef
#和stack相似
#如是使用undefine 则所以的define都会别移除

#indirect call a macros
#所有的macros都可以被间接调用。
#使用indir
#indir(name,[arg...])
#只有使用arugment 掉用时indir才会被识别
#可以用来调用无效名字的Macros

#ifdef(name, string-1,[string-2])
#测试是否定义了一个宏
#如果定义了name，就扩展stringj-1,
#否则就扩占string-2,if string-2 is omitted.
#就会扩增为empty-stirng


## EE 如何输出\t \r \n ??


## DEBUG
## EE dumpdef([name...]) 
#把指定的Macro的定义打印到stderr
#如果找不到输出错误

# EE traceon([name...]) 
#    traceoff([name...])
# 跟踪Marco的调用和替换
